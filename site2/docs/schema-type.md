---
id: schema-type
title: Schema type
sidebar_label: Schema type
---

Pulsar supports various schema types, which are mainly divided into two categories: 

* Primitive type 

* Complex type

> #### Note
> 
> If you create a schema without specifying a type, producers and consumers can only handle raw bytes.

## Primitive type

Currently, Pulsar supports the following primitive types:

| Primitive Type | Description |
|---|---|
| `BOOLEAN` | A binary value |
| `INT8` | A 8-bit signed integer |
| `INT16` | A 16-bit signed integer |
| `INT32` | A 32-bit signed integer |
| `INT64` | A 64-bit signed integer |
| `FLOAT` | A single precision (32-bit) IEEE 754 floating-point number |
| `DOUBLE` | A double-precision (64-bit) IEEE 754 floating-point number |
| `BYTES` | A sequence of 8-bit unsigned bytes |
| `STRING` | A Unicode character sequence |
| `TIMESTAMP` (`DATE`, `TIME`) |  A logic type represents a specific instant in time with millisecond precision. It stores the number of milliseconds since `January 1, 1970, 00:00:00 GMT` as an `INT64` value | 

For primitive types, Pulsar does not store any schema data in `SchemaInfo`. The `type` in `SchemaInfo` is used to determine how to serialize and deserialize the data. 

Some of the primitive schema implementations can use `properties` to store implementation-specific tunable settings. For example, a `string` schema can use `properties` to store the encoding charset to serialize and deserialize strings.

The conversions between **Pulsar schema types** and **language-specific primitive types** are as below.

| Schema Type | Java Type| Python Type |
|---|---|---|
| BOOLEAN | boolean | bool |
| INT8 | byte | |
| INT16 | short | | 
| INT32 | int | |
| INT64 | long | |
| FLOAT | float | float |
| DOUBLE | double | float |
| BYTES | byte[], ByteBuffer, ByteBuf | bytes |
| STRING | string | str |
| TIMESTAMP | java.sql.Timestamp | |
| TIME | java.sql.Time | |
| DATE | java.util.Date | |

**Example**

This example demonstrates how to use a string schema.

1. Create a producer with a string schema and send messages.

    ```text
    Producer<String> producer = client.newProducer(Schema.STRING).create();
    producer.newMessage().value("Hello Pulsar!").send();
    ```

2. Create a consumer with a string schema and receive messages.  

    ```text
    Consumer<String> consumer = client.newConsumer(Schema.STRING).create();
    consumer.receive();
    ```

## Complex type

Currently, Pulsar supports the following complex types:

| Complex Type | Description |
|---|---|
| `keyvalue` | Represents a complex type of a key/value pair. |
| `struct` | Supports AVRO, JSON, and Protobuf. |

### `keyvalue`

For `SchemaInfo` of `keyvalue` schema, Pulsar stores the `SchemaInfo` of key schema and the `SchemaInfo` of value schema together.

### `struct`

Pulsar uses [Avro Specification](http://avro.apache.org/docs/current/spec.html) to declare the schema definition for `struct` schema. This allows Pulsar:

* to use same tools to manage schema definitions

* to use different serialization/deserialization methods to handle data

There are two methods to use `struct` schema. 

### **Static**

You can predefine the `struct` schema, and it can be a POJO in Java, a `struct` in Go, or classes generated by Avro or Protobuf tools. 

**Example** 

Pulsar gets the schema definition from the predefined `struct` using an Avro library. The schema definition is the schema data stored as a part of the schema info.

1. Create the _User_ class to define the messages sent to Pulsar topics.

    ```text
    public class User {
        String name;
        int age;
    }
    ```

2. Create a producer with a `struct` schema and send messages.

    ```text
    Producer<User> producer = client.newProducer(Schema.AVRO(User.class)).create();
    producer.newMessage().value(User.builder().userName("pulsar-user").userId(1L).build()).send();
    ```

3. Create a consumer with a `struct` schema and receive messages

    ```text
    Consumer<User> consumer = client.newConsumer(Schema.AVRO(User.class)).create();
    User user = consumer.receive();
    ```

### Generic

Sometimes applications do not have pre-defined structs, and you can use this method to define schema and access data.

You can define the `struct` schema using the `GenericSchemaBuilder`, generate a generic struct using `GenericRecordBuilder` and consume messages into `GenericRecord`.

**Example** 

1. Use `RecordSchemaBuilder` to build a schema.

    ```text
    RecordSchemaBuilder recordSchemaBuilder = SchemaBuilder.record("schemaName");
    recordSchemaBuilder.field("intField").type(SchemaType.INT32);
    SchemaInfo schemaInfo = recordSchemaBuilder.build(SchemaType.AVRO);

    Producer<GenericRecord> producer = client.newProducer(Schema.generic(schemaInfo)).create();
    ```

2. Use `RecordBuilder` to build the struct records.

    ```text
    producer.newMessage().value(schema.newRecordBuilder()
                .set("intField", 32)
                .build()).send();
    ```